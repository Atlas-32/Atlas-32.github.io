(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{490:function(t,v,_){"use strict";_.r(v);var a=_(4),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),_("p",[t._v("HTTP是无状态的，也就是说，它是不对通信状态进行保存的。它并不知道之前通信的对方是谁。这样设计的目的就是为了让HTTP简单化，能够快速处理大量的事务。")]),t._v(" "),_("p",[t._v("但是，我们经常是需要知道访问的人是谁，于是就有了Cookie技术了。要是服务器端想要记住客户端是谁，那么就颁发一个cookie给客户端。客户端把Cookie保存在硬盘中，当下次访问服务器的时候，浏览器会自动把客户端的cookie带过去。服务器就能够知道这家伙是谁了。")]),t._v(" "),_("h2",{attrs:{id:"http版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http版本"}},[t._v("#")]),t._v(" HTTP版本")]),t._v(" "),_("p",[t._v("HTTP1.1：增加了持久化连接和host字段")]),t._v(" "),_("p",[t._v("HTTP2：")]),t._v(" "),_("p",[t._v("二进制编码：")]),t._v(" "),_("p",[t._v("多路复用：由于二进制帧的出现，帧可以在流中不按序传输，到达后再组装，解决了 HTTP/1.x 可能出现的头部阻塞问题")]),t._v(" "),_("p",[t._v("头部压缩：在客户端和服务器端使用“首部表”来记录发送过的键值对，对于相同的数据，不再通过每次请求和响应发送")]),t._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("p",[t._v("用户向服务器发起一个安全连接的请求\n服务器返回经过CA认证的数字证书，证书里面包含了服务器的公钥\n用户拿到数字证书，用自己浏览器内置的CA证书解密得到服务器的公钥\n用户用服务器的公钥加密一个用于接下来的对称加密算法的会话密钥，传给服务器\n服务器用私钥解密得到会话密钥\n双方使用会话密钥进行交流")]),t._v(" "),_("p",[t._v("用户要对数字证书进行认证\n服务器要检查接收的信息的数字签名，确保不会被篡改")]),t._v(" "),_("h2",{attrs:{id:"跨域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),_("p",[t._v("协议 域名 端口")]),t._v(" "),_("blockquote",[_("p",[t._v("跨域解决方案：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("通过 jsonp（只能 GET）")])]),t._v(" "),_("li",[_("p",[t._v("document.domain + iframe（仅限主域相同，子域不同）")])]),t._v(" "),_("li",[_("p",[t._v("location.hash + iframe")])]),t._v(" "),_("li",[_("p",[t._v("window.name + iframe")])]),t._v(" "),_("li",[_("p",[t._v("postMessage")])]),t._v(" "),_("li",[_("p",[t._v("跨域资源共享（CORS）")]),t._v(" "),_("p",[t._v("服务端 Header: Access-Control-Allow-Origin")])]),t._v(" "),_("li",[_("p",[t._v("nginx 反向代理")]),t._v(" "),_("p",[t._v("nodejs 中间件代理")])]),t._v(" "),_("li",[_("p",[t._v("WebSocket 协议")])])])]),t._v(" "),_("h2",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),_("p",[t._v("三次握手、四次挥手")]),t._v(" "),_("p",[t._v("TCP UDP")]),t._v(" "),_("h2",{attrs:{id:"http方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http方法"}},[t._v("#")]),t._v(" HTTP方法")]),t._v(" "),_("blockquote",[_("p",[t._v("GET POST区别")])]),t._v(" "),_("h2",{attrs:{id:"缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),_("p",[t._v("强制缓存：在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求。强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。")]),t._v(" "),_("p",[t._v("协商缓存：协商缓存每次读取数据时都需要跟服务器通信，并且会增加缓存标识。在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回304状态码，浏览器就读取本地缓存服务器中的数据。")]),t._v(" "),_("h2",{attrs:{id:"攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#攻击"}},[t._v("#")]),t._v(" 攻击")]),t._v(" "),_("p",[t._v("CSRF 跨站请求伪造：")]),t._v(" "),_("p",[t._v("防范方法：验证refer字段、加入token")]),t._v(" "),_("p",[t._v("XSS 跨站脚本攻击：恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，嵌入恶意代码到网站中。")]),t._v(" "),_("p",[t._v("防范方法：不可信任任何用户提交的数据，必须对部分敏感字符进行转义、过滤。")])])}),[],!1,null,null,null);v.default=s.exports}}]);